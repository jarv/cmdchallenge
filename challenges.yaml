---
# slug: name of the challenge (required)
# description: describe teh challenge (required)
# example: solution for the challenge (required)
# expect_fail: A command that expects a failure because of randomizers
# expected_output:
#   lines: lines returned from the command, as an array.
#          Values *must* be strings, not integers! (required)
#   order: whether or not order matters (optional, default is true)
#   re_sub: regex substitution on the output lines (optional)
#   regex: lines are regular expressions (optional)
#   version: *REQUIRED* if the challenge is modified this number should be bumped
#            refresh the cache.
#   author: Add a field for contributions.
#   completions: Array of completions for challenge
#   tags: Array of tags used to filter for different flavors of cmdchallenge
#   cache_correct: Cache correct answers (defaults to True)
#   cache_incorrect: Cache incorrect answers (defaults to True)
#   dir: Directory for the challenge, by default uses the slug unless this is set
#   disp_learn: Diaply the learn box by default (true/false), default false

- slug: 12days_1
  version: 1
  disp_title: A list of files
  dir: night_before_christmas
  emoji: 12days/12days_1
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the first day of Shell my true love gave to me<br />
    A list of files in the directory tree ...
    </div>
  learn: |
    You've stumbled upon a festive adventure where you need to type single commands into your browser to get Christmas presents!
    As a reward for your efforts, you might learn a little bit about the command line.

    On just about every Unix and Unix-like operating systems there is a command named `ls`. <br />
    `ls` is short for "list" and can be used to list files in your current working directory.

    Try sending the command `ls` in the command box to list all files in the directory.
  disp_learn: true
  example: ls
  expected_output:
    lines:
      - night-before-christmas.txt
  tags: ["12days"]
- slug: 12days_2
  version: 1
  disp_title: Two lines a-laughing
  dir: night_before_christmas
  emoji: 12days/12days_2
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the second day of Shell my true love gave to me<br />
    Two lines a-laughing ...
    </div>

    ---
    _If you aren't sure what to do, expand the "learn" section above._<br />
    _You can also view user solutions by expanding "View Solutions" above_
  learn: |
    What's so funny? Let's look for lines in our Christmas poem that are laughing.

    `grep` is the most common command-line utility for extracting text from a file.<br />
    The syntax of the command is `grep PATTERN <file>`.<br />
    `PATTERN` is a string, and refers to a [basic regular expression](https://www.gnu.org/software/sed/manual/html_node/BRE-syntax.html).<br />
    All you need to know for now is to set `PATTERN` to the string you are looking for.

    In this example you might try:

    ```
    grep laugh night-before-christmas.txt
    ```

    Which will print every single line that contains the string "laugh".<br />
    There are many options for the `grep` command, for example to do a case-insensitive search you would type:

    ```
    grep -i laugh night-before-christmas.txt
    ```

    To see all available options check out the man page by sending the command `man grep` or the help `grep --help`.

  example: grep laugh night-before-christmas.txt
  expected_output:
    lines:
      - That shook when he laughed, like a bowlful of jelly.
      - And I laughed when I saw him, in spite of myself;
  tags: ["12days"]
- slug: 12days_3
  version: 1
  disp_title: Three lines at the beginning
  dir: night_before_christmas
  emoji: 12days/12days_3
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the third day of Shell my true love gave to me<br />
    Three lines at the beginning ...
    </div>
  learn: |
    When you have a text file, it's common to only need to see the top N lines.
    Included in most Unix-like systems is a utility named `head`.
    By default, it will display the first 10 lines of the file.

    To display the first 3 lines, you will need to use the option `-n 3`.

    Try sending the command:

    ```
    head -n 3 night-before-christmas.txt
    ```

  example: head -3 night-before-christmas.txt
  expected_output:
    lines:
      - "'Twas the night before Christmas, when all through the house"
      - "Not a creature was stirring, not even a mouse;"
      - "The stockings were hung by the chimney with care"
  tags: ["12days"]
- slug: 12days_4
  version: 1
  disp_title: Four lines at the end
  dir: night_before_christmas
  emoji: 12days/12days_4
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the fourth day of Shell my true love gave to me<br />
    Four lines at the end ...
    </div>
  learn: |
    Just like we needed to look at the beginning lines on day three, a utility called `tail` can be used to look at the bottom N lines.
    By default it will display the last 10 lines so like before you will need to use the `-n` option.

    ```
    tail -n 4 night-before-christmas.txt
    ```
  example: tail -4 night-before-christmas.txt
  expected_output:
    lines:
      - "He sprang to his sleigh, to his team gave a whistle,"
      - "And away they all flew like the down of a thistle."
      - "But I heard him exclaim, ere he drove out of sight,"
      - '"Happy Christmas to all, and to all a good-night."'
  tags: ["12days"]
- slug: 12days_5
  version: 1
  disp_title: Five lines that start with "the"
  dir: night_before_christmas
  emoji: 12days/12days_5
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the fifth day of Shell my true love gave to me<br />
    Five lines that start with "the" ...
    </div>
  learn: |
    We already used `grep` to extract a string from a file earlier so if you were thinking we would use `grep` again you are on the right track!

    Here we want to find all lines that start with the word "the".
    One way you could do this is look for a capital "T" since the beginning of every sentence is capatilized.<br />
    Since `grep` is case sensitive by default, one way would be to search for the string `The`

    We mentioned early that the PATTERN in `grep PATTERN <file>` refers to a [basic regular expression](https://www.gnu.org/software/sed/manual/html_node/BRE-syntax.html).<br />
    This allows to do more than simple string matches by using the basic regular expression syntax.<br />
    One example is the `^` character which will anchor the search to the start of every string.<br />
    This type of character is called a [regex anchor](https://www.regular-expressions.info/anchors.html).<br />

    To do a case-insenstive search for the word `the` but only match it at the _beginning_ of every line, you will need to use a combination of `-i` for case insenstive match and an `^` anchor.

    For example:

    ```
    grep -i "^the" night-before-christmas.txt
    ```

    Try it below!
  example: grep -i "^the" night-before-christmas.txt
  expected_output:
    lines:
      - The stockings were hung by the chimney with care
      - The children were nestled all snug in their beds,
      - The moon on the breast of the new-fallen snow
      - The prancing and pawing of each little hoof.
      - The stump of a pipe he held tight in his teeth,
  tags: ["12days"]
- slug: 12days_6
  version: 1
  disp_title: Six lines that are exciting!
  dir: night_before_christmas
  emoji: 12days/12days_6
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the sixth day of Shell my true love gave to me<br />
    Six lines that are exciting! ...
    </div>

    ---
    _Hint: Exciting lines end with "!"_
  learn: |
    To find "exciting" lines we want to only print lines that end with a `!` character.<br />
    Just like how previously we learned that regular expression syntax can match strings with an anchor at the beginning of the line we can use `$` to anchor the match at the end.

    ```
    grep '!$' night-before-christmas.txt
    ```

    One important thing to be aware of is that the character `!` is a [special character](https://www.oreilly.com/library/view/learning-the-bash/1565923472/ch01s09.html) for the shell.<br />
    To ensure that this works correctly you will need to either use single-quotes like above, or escape it with a `\`:

    ```
    grep \!$ night-before-christmas.txt
    ```
  example: grep \!$ night-before-christmas.txt
  expected_output:
    lines:
      - Now, Dasher! now, Dancer! now, Prancer and Vixen!
      - On, Comet! on, Cupid! on, Donder and Blitzen!
      - To the top of the porch! to the top of the wall!
      - Now dash away! dash away! dash away all!
      - His eyes--how they twinkled! his dimples how merry!
      - His cheeks were like roses, his nose like a cherry!
  tags: ["12days"]
- slug: 12days_7
  version: 1
  disp_title: Seven files that start with Santa
  dir: santa
  emoji: 12days/12days_7
  completions: ["night-before-christmas.txt"]
  description: |
    <div class="twelve-days">
    On the seventh day of Shell my true love gave to me<br />
    Seven files that start with "Santa" ...
    </div>
  learn: |
    Now there are more than just one file in the working directory. Like the first day, we will need to use the `ls` command to list them.<br />
    Unlike before, we need to limit the output to only files that begin with the string "Santa".<br />
    To do this, we will need to use a feature of most shells that is called wildcarding or [globbing](https://tldp.org/LDP/abs/html/globbingref.html).

    To create a wildcard, you will use the `*` character which will match zero or more characters after the string.<br />
    For example, to match anything that starts with the string "Santa" you will need to send:

    ```
    ls Santa*
    ```

    If you wanted to list files that start with "Santa" or "santa" there is another feature you can use that can match multiple characters called [ranges](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_03.html).<br />
    For example:

    ```
    ls [Ss]anta*
    ```

    Will match both files named `Santa's hat` and `santa's toys`.
  example: ls -1  [Ss]anta*
  expected_output:
    order: false
    re_sub: ['^.*\/', '']
    lines:
      - Santa's beard
      - Santa's belly
      - Santa's hat
      - Santa's reindeer
      - Santa's sleigh
      - Santa's toys
      - Santa's village
  tags: ["12days"]
- slug: 12days_8
  version: 2
  disp_title: Eight elves
  dir: elves
  emoji: 12days/12days_8
  completions: ["Elves", "Workshop", "Hermey", "Pepper Minstix", "Shinny Upatree", "Buddy", "Wunorse Openslae", "Alabaster Snowball", "Bushy Evergreen", "Sugarplum Mary"]
  description: |
    <div class="twelve-days">
    On the eighth day of Shell my true love gave to me<br />
    Eight elves in Santa's Workhop/ ...
    </div>
  learn: |
    The elves are lost and only you can help them get back into Santa's workshop!

    You can see where they are by sending the command `ls Elves/`. This will list all the files in the "Elves/" directory.
    To move them to the `Workhop/` we will need to use the `mv` command and the `*` wildcard that was used on Day 7.

    The `mv` command will move one more more files from one location to a new one. <br />
    If you specify multiple files, all the files will be moved to the last argument which is the destination.

    For example:

    ```
    mv file1 file2 file3 destination/
    ```
    Will move all three files to the folder named `destination/`

    To move every file in in `Elves/` we can use a wildcard `Elves/*`, and move them by sending the following command:

    ```
    mv Elves/* Workshop/
    ```
  example: mv Elves/* Workshop/
  expected_failures: ["cp Elves/* Workshop/"]
  tags: ["12days"]
- slug: 12days_9
  version: 1
  dir: nine_reindeer
  emoji: 12days/12days_9
  completions: ["Vixen", "North Pole", "Stable", "Prancer", "Comet", "Cupid", "Dancer", "Santa's Village", "Santa's Workshop", "Rudolph", "Dasher", "Blixem", "Dunder"]
  disp_title: Nine Reindeer
  description: |
    <div class="twelve-days">
    On the ninth day of Shell my true love gave to me<br />
    Nine names of Santa's Reindeer ...
    </div>
  learn: |
    Santa's nine Reindeer are lost in sub-directories, can you find them?

    Here we introduce a common utility called `find` which as you can probably guess, is
    used to find files. The Reindeer are hiding in sub-directories, to search for them
    in the current directory we use `.` as the first option to `find`. `.` is just another
    way of specifying the current working directory that you are in.

    Try sending:

    ```
    find .
    ```

    This will find both directories **and** files which is not what we want. <br />
    In order to display only files, you will need to use the `-type f` argument to `find`:

    ```
    find . -type f
    ```
  example: find . -type f
  expected_output:
    order: false
    re_sub: ['^.*\/', '']
    lines:
      - Dasher
      - Rudolph
      - Dancer
      - Prancer
      - Vixen
      - Comet
      - Cupid
      - Dunder
      - Blixem
  tags: ["12days"]
- slug: 12days_10
  version: 1
  dir: lords
  emoji: 12days/12days_10
  completions: ["lords.txt"]
  disp_title: Ten Lords
  description: |
    <div class="twelve-days">
    On the tenth day of Shell my true love gave to me<br />
    Ten Lords by their names sorted ...
    </div>
  learn: |
    The Ten Lords are all mixed up!

    Sorting is something we do often on the command line.
    There is a file named `lords.txt` that contains a list of lords. We can
    use the command `sort` to sort the contents and print them, by default
    it will sort the file in dictionary order.

    ```
    sort lords.txt
    ```
  example: sort lords.txt
  expected_output:
    lines:
      - Lord Asriel
      - Lord Buckethead
      - Lord Drinian
      - Lord Elrond
      - Lord Farquaad
      - Lord Gendry
      - Lord Glenarvan
      - Lord Macduff
      - Lord Palpatine
      - Lord Snooty
  tags: ["12days"]
- slug: 12days_11
  version: 1
  dir: pipers
  emoji: 12days/12days_11
  completions: ["place-for-pipers", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "piper", "not-a-piper"]
  disp_title: Eleven Pipers
  description: |
    <div class="twelve-days">
    On the eleventh day of Shell my true love gave to me<br />
    Eleven lines with pipers ♫ piping ♫ ...
    </div>
  learn: |
    The pipers are playing their pipes but also other music, can you print the piping music?

    Here we find ourselves in a directory with files named `piper`, each file
    with one line matching the string "♫ piping ♫". <br />
    To only output the lines that match "♫ piping ♫" we will need to first find
    the files that contain the string, and then output their contents.

    Earlier we used the `find` command to find files, here we will use it again to
    find files named `piper`:

    ```
    find . -name "piper" -type f
    ```

    To look for specific strings in each `find` result, the `-exec` can be used to execute a
    command for every file found. The special string `{}` can be used as a substitute for the
    filename. For example:

    ```
    find . -name "piper" -type f -exec grep piping {} \;
    ```

    will search for the string "piping" and execute `grep` in every file that find returns.
    The `\;` is an escaped `;` that ends the command that is executed.

    There are a lot of different ways to get the same result, see the solutions for more examples.
    It's even possible to play the pipers piping using a pipe!
  example: find . -name "piper" -exec grep piping {} \;
  expected_output:
    lines:
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
      - ♫ piping ♫
  tags: ["12days"]
- slug: 12days_12
  disp_learn: true
  version: 1
  dir: twelve_days_of_shell
  emoji: 12days/12days_12
  completions: ["twelve-days-of-shell.txt"]
  disp_title: Twelve days of Shell
  description: |
    <div class="twelve-days">
    On the twelfth day of Shell my true love gave to me<br />
    Twelve Days of Shell on the terminal!
    </div>
  learn: |
    We have reached the twelfth day of Shell!<br />
    For the final day all you need to do is print out the contents of `twelve-days-of-shell.txt`.

    If you enjoyed these exercises [follow us on twitter](https://twitter.com/thecmdchallenge)
    or try more [command line challenges](https://cmdchallenge.com)!
  example: cat twelve-days-of-shell.txt
  expected_output:
    lines:
      - 🥁 🎵 🎶 🎵 🥁
      - On the twelfth day of Shell my true love gave to me
      - Twelve days of Shell on the terminal
      - Eleven lines with pipers ♫ piping ♫
      - Ten lords by their names sorted
      - Nine names of Santa's reindeer
      - Eight elves in Santa's Workhop/
      - Seven files that start with "Santa"
      - Six lines that are exciting!
      - Five lines that start with "the"
      - Four lines at the end
      - Three lines at the beginning
      - Two lines a-laughing
      - And a list of files in the directory tree
      - 🥁 🎵 🎶 🎵 🥁
  tags: ["12days"]
- slug: oops_cwd
  emoji: emojis/1F62D
  disp_title: current working directory
  version: 2
  description: |
    A process on this computer managed to delete all of the files in
    the /bin and /usr/bin directories!

    ---
    The good news is that you still have a shell prompt, the bad news
    is that you are only able to execute one command to complete each challenge.

    For now, all you need to do is figure out where you are,
    print the current working directory.
  example: pwd
  expected_output:
    lines:
      - '/var/challenges/oops_cwd'
  img: cmd-no-bin
  tags: ["oops"]
- slug: oops_list_files
  disp_title: list files
  version: 3
  emoji: emojis/1F92F
  description: |
    Great, now that you know which directory you are in, you want to see what else
    is here. List all of the files on a single line, in the current working directory.

    Hint: You won't be able to use the `ls` command, instead you will need to use
    a bash builtin
  expected_failures:
    - echo "another-file.txt my-dissertation.txt"
  expected_output:
    lines:
      - 'another-file.txt my-dissertation.txt'
  example: echo *
  img: cmd-no-bin
  tags: ["oops"]
- slug: oops_print_file_contents
  disp_title: print file contents
  version: 2
  emoji: emojis/1F630
  description: |
    Oh no! You now remember there is a very important file in this directory.

    Display its contents before the data is lost for forever!
  completions: ["my-dissertation.txt"]
  example: 'while read x; do echo $x; done < my-dissertation.txt'
  expected_output:
    lines:
      - "Rooter: A Methodology for the Typical Unification"
      - ""
      - of Access Points and Redundancy
      - ""
      - Jeremy Stribling, Daniel Aguayo and Maxwell Krohn
      - ""
      - ABSTRACT
      - ""
      - Many physicists would agree that, had it not been for
      - congestion control, the evaluation of web browsers might never
      - have occurred. In fact, few hackers worldwide would disagree
      - with the essential uniﬁcation of voice-over-IP and public-
      - private key pair. In order to solve this riddle, we conﬁrm that
      - SMPs can be made stochastic, cacheable, and interposable.
      - ...
  img: cmd-no-bin
  tags: ["oops"]
- slug: oops_print_process
  disp_title: print process name
  version: 2
  emoji: emojis/1F627
  description: |
    You know there is a process on machine that is deleting files, the first thing
    you want to do is identify the name of it. Print the name of the process

    Hint: process information is stored in /proc, maybe there is a something there
    that will help?
  example: 'read x < /proc/42/cmdline ; echo $x'
  expected_output:
    lines:
      - 'oops-this-will-delete-bin-dirs'
  img: cmd-no-bin
  tags: ["oops"]
- slug: oops_kill_a_process
  disp_title: kill a process
  version: 2
  emoji: emojis/1F625
  description: |
    You are doing great!

    You managed to save your important file.
    Now that you know the process name
    it will be good to kill it before it does any more damanage.

    Kill the running process
  example: 'kill -9 42'
  expected_failures:
    - echo
  img: cmd-no-bin
  tags: ["oops"]
- slug: hello_world
  emoji: emojis/1F40C
  disp_title: hello world
  version: 5
  author: cmdchallenge
  description: |
    Your first challenge is to print "hello world" on the terminal in a single command.

    Hint: There are many ways to print text on the command line, one way is with the 'echo' command.
    Try it below and good luck!
  completions: ["place your advertisement here!"]
  example: echo 'hello world'
  expected_failures:
    - echo "nope"
  expected_output:
    lines:
      - 'hello world'
- slug: current_working_directory
  emoji: emojis/1F98B
  disp_title: cwd
  version: 5
  author: cmdchallenge
  description: |
    Print the current working directory.
  example: pwd
  expected_failures:
    - echo "nope"
  expected_output:
    lines:
      - '/var/challenges/current_working_directory'
- slug: list_files
  emoji: emojis/1F41B
  disp_title: list files
  version: 8
  author: cmdchallenge
  description: |
    List names of all the files in the current directory, one file per line.
  example: ls
  expected_output:
    order: false
    lines:
      - '01-take.txt'
      - '02-the.txt'
      - '03-command.txt'
      - '04-challenge.txt'
  expected_failures:
    - echo -e "01-take.txt\n02-the.txt\n03-command.txt\n04-challenge.txt"
- slug: print_file_contents
  emoji: emojis/1F41C
  disp_title: file contents
  version: 5
  author: cmdchallenge
  description: |
    There is a file named `access.log` in the current directory. Print the contents.
  completions: ["access.log"]
  example: cat access.log
  expected_output:
    lines:
      - 163.56.115.58 - - [09/Jan/2017:22:29:57 +0100] "GET /posts/2/display HTTP/1.0" 200 3240
      - 75.113.188.234 - - [09/Jan/2017:22:30:43 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 1116
      - 69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] "GET /pages/create HTTP/1.0" 500 3471
      - 225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 500 2477
      - 207.243.19.2 - - [09/Jan/2017:22:38:03 +0100] "GET /bar/create HTTP/1.0" 200 1116
      - 199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] "GET /posts/1/display HTTP/1.0" 200 2477
      - 55.74.240.123 - - [09/Jan/2017:22:44:25 +0100] "POST /posts/1/display HTTP/1.0" 200 3471
      - 251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 2477
      - 101.163.230.250 - - [09/Jan/2017:22:52:31 +0100] "DELETE /posts/2/display HTTP/1.0" 404 2477
      - 200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 3471
- slug: last_lines
  emoji: emojis/1F578
  version: 5
  author: cmdchallenge
  disp_title: last lines
  description: |
    Print the last 5 lines of "access.log".
  completions: ["access.log"]
  example: tail -n 5 access.log
  expected_output:
    lines:
      - 199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] "GET /posts/1/display HTTP/1.0" 200 2477
      - 55.74.240.123 - - [09/Jan/2017:22:44:25 +0100] "POST /posts/1/display HTTP/1.0" 200 3471
      - 251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 2477
      - 101.163.230.250 - - [09/Jan/2017:22:52:31 +0100] "DELETE /posts/2/display HTTP/1.0" 404 2477
      - 200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 3471
- slug: create_file
  emoji: emojis/1F433
  disp_title: Create a file
  version: 2
  author: cmdchallenge
  description: |
    Create an empty file named `take-the-command-challenge` in the current working directory.
  completions: ["take-the-command-challenge"]
  example: touch take-the-command-challenge
  expected_failures:
    - echo
    - echo ' ' > take-the-command-challenge
- slug: create_directory
  emoji: emojis/1F40B
  disp_title: Create a directory
  version: 1
  author: cmdchallenge
  description: |
    Create a directory named `tmp/files` in the current working directory
  completions: ["take-the-command-challenge", "tmp/files"]
  example: mkdir -p tmp/files
  expected_failures:
    - echo
- slug: copy_file
  emoji: emojis/1F42C
  disp_title: copy file
  version: 3
  author: cmdchallenge
  description: |
    Copy the file named `take-the-command-challenge` to the directory `tmp/files`
  completions: ["take-the-command-challenge", "tmp/files"]
  example: cp take-the-command-challenge tmp/files/.
  expected_failures:
    - echo
    - mv take-the-command-challenge tmp/files
- slug: move_file
  emoji: emojis/1F41F
  disp_title: move file
  version: 1
  author: cmdchallenge
  description: |
    Move the file named `take-the-command-challenge` to the directory `tmp/files`
  completions: ["take-the-command-challenge", "tmp/files"]
  example: mv take-the-command-challenge tmp/files/.
  expected_failures:
    - echo
- slug: create_symlink
  emoji: emojis/1F420
  disp_title: create symlink
  version: 1
  author: cmdchallenge
  description: |
    A symbolic link is a type of file that is a reference to another file.

    Create a symbolic link named `take-the-command-challenge` that points to the
    file `tmp/files/take-the-command-challenge`.
  completions: ["take-the-command-challenge", "tmp/files/take-the-command-challenge"]
  example: ln -s /var/challenges/create_symlink/tmp/files/take-the-command-challenge
  expected_failures:
    - echo
- slug: delete_files
  emoji: emojis/1F421
  disp_title: delete files
  version: 7
  author: cmdchallenge
  description: |
    Delete all of the files in this challenge directory including all subdirectories and their contents.
  example: find . -delete
  expected_failures:
    - rm -rf /var/challenges/delete_files
- slug: remove_files_with_extension
  emoji: emojis/1F43A
  version: 5
  author: cmdchallenge
  disp_title: remove files with extension
  description: |
    There are files in this challenge with different file extensions.
    Remove all files with the .doc extension recursively in the current working directory.
  example: rm **/*.doc
  expected_failures:
    - echo
- slug: find_string_in_a_file
  emoji: emojis/1F41D
  disp_title: find string
  version: 5
  author: cmdchallenge
  description: |
    There is a file named `access.log` in the current working directory. Print all lines in this file that contains the string "GET".
  completions: ["access.log"]
  example: grep 'GET' access.log
  expected_output:
    lines:
      - 163.56.115.58 - - [09/Jan/2017:22:29:57 +0100] "GET /posts/2/display HTTP/1.0" 200 3240
      - 75.113.188.234 - - [09/Jan/2017:22:30:43 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 1116
      - 69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] "GET /pages/create HTTP/1.0" 500 3471
      - 225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 500 2477
      - 207.243.19.2 - - [09/Jan/2017:22:38:03 +0100] "GET /bar/create HTTP/1.0" 200 1116
      - 199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] "GET /posts/1/display HTTP/1.0" 200 2477
      - 251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 2477
      - 200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 3471
- slug: search_for_files_containing_string
  emoji: emojis/1F41E
  disp_title: search for string
  version: 6
  author: cmdchallenge
  description: |
    Print all files in the current directory, one per line (not the path, just the filename) that contain the string "500".
  completions: ["access.log"]
  example: grep -l 500 *
  expected_failures:
    - 'ls *[^2]'
  expected_output:
    order: false
    lines:
      - access.log
      - access.log.1
- slug: search_for_files_by_extension
  emoji: emojis/1F997
  disp_title: search for extension
  version: 5
  author: cmdchallenge
  description: |
    Print the relative file paths, one path per line for all filenames that start with "access.log" in the current directory.
  completions: ["access.log"]
  example: find . -name 'access.log*'
  expected_output:
    order: false
    re_sub: ['^\./', '']
    lines:
      - 'access.log'
      - 'access.log.1'
      - 'access.log.2'
- slug: search_for_string_in_files_recursive
  emoji: emojis/1F577
  disp_title: search recursive
  version: 5
  author: cmdchallenge
  description: |
    Print all matching lines (without the filename or the file path) in all files under the current directory that start with "access.log" that contain the string "500".

    Note that there are no files named `access.log` in the current directory, you will need to search recursively.
  completions: ["access.log"]
  example: grep -h 500 **/access.log*
  expected_output:
    order: false
    lines:
      - 69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] "GET /pages/create HTTP/1.0" 500 3471
      - 225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 500 2477
      - 2.71.250.27 - - [09/Jan/2017:22:41:26 +0100] "GET /pages/create HTTP/1.0" 500 2477
- slug: extract_ip_addresses
  emoji: emojis/1F982
  disp_title: find ip address
  version: 5
  author: cmdchallenge
  description: |
    Extract all IP addresses from files that start with "access.log" printing one IP address per line.
  completions: ["access.log"]
  example: grep -Pho '^\d+\.\d+\.\d+\.\d+' **/access.log*
  expected_output:
    re_sub: ['^[\w/.]*?:', '']
    order: false
    lines:
      - 163.56.115.58
      - 75.113.188.234
      - 69.16.40.148
      - 225.219.54.140
      - 207.243.19.2
      - 199.37.62.156
      - 55.74.240.123
      - 251.111.109.143
      - 101.163.230.250
      - 200.19.168.148
      - 108.68.174.15
      - 17.2.20.139
      - 28.151.137.59
      - 199.150.241.179
      - 2.71.250.27
      - 17.137.186.194
      - 151.84.119.34
      - 4.180.204.195
      - 9.230.96.54
      - 157.143.233.21
- slug: count_files
  emoji: emojis/1FAB0
  disp_title: count files
  version: 8
  author: cmdchallenge
  description: |
    Count the number of files in the current working directory. Print the number of files as a single integer.
  example: find -L . -type f | wc -l
  expected_failures:
    - echo 2
  expected_output:
    re_sub: ['^\s+', '']
    lines:
      - '2'
- slug: simple_sort
  emoji: emojis/1FAB1
  disp_title: simple sort
  version: 5
  author: cmdchallenge
  description: |
    Print the contents of access.log sorted.
  completions: ["access.log"]
  example: sort access.log
  expected_output:
    lines:
      - 101.163.230.250 - - [09/Jan/2017:22:52:31 +0100] "DELETE /posts/2/display HTTP/1.0" 404 2477
      - 163.56.115.58 - - [09/Jan/2017:22:29:57 +0100] "GET /posts/2/display HTTP/1.0" 200 3240
      - 199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] "GET /posts/1/display HTTP/1.0" 200 2477
      - 200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 3471
      - 207.243.19.2 - - [09/Jan/2017:22:38:03 +0100] "GET /bar/create HTTP/1.0" 200 1116
      - 225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 500 2477
      - 251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 2477
      - 55.74.240.123 - - [09/Jan/2017:22:44:25 +0100] "POST /posts/1/display HTTP/1.0" 200 3471
      - 69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] "GET /pages/create HTTP/1.0" 500 3471
      - 75.113.188.234 - - [09/Jan/2017:22:30:43 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 1116
- slug: count_string_in_line
  emoji: emojis/1F9A0
  disp_title: count the strings
  version: 6
  author: cmdchallenge
  description: |
    Print the number of lines in access.log that contain the string "GET".
  completions: ["access.log"]
  example: grep -c "GET" access.log
  expected_failures:
    - echo 8
  expected_output:
    re_sub: ['^\s+', '']
    lines:
      - '8'
- slug: split_on_a_char
  emoji: emojis/1F435
  disp_title: split on a char
  version: 5
  author: cmdchallenge
  description: |
    The file split-me.txt contains a list of numbers separated by a `;` character.

    Split the numbers on the `;` character, one number per line.
  completions: ["split-me.txt"]
  example: tr ';' '\n' < split-me.txt
  expected_output:
    lines: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]
- slug: print_number_sequence
  emoji: emojis/1F436
  disp_title: generate a number sequence
  version: 5
  author: cmdchallenge
  description: |
    Print the numbers 1 to 100 separated by spaces.
  example: echo $(seq 1 100)
  expected_output:
    lines:
      - 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
- slug: replace_text_in_files
  emoji: emojis/1F98A
  disp_title: replace text in files
  version: 5
  author: cmdchallenge
  example: sed -i 's/challenges are difficult//g' **/*.txt
  expected_failures:
    - echo
  description: |
    This challenge has text files (with a .txt extension) that contain the phrase "challenges are difficult".  Delete this phrase from all text files recursively.

    Note that some files are in subdirectories so you will need to search for them.
- slug: sum_all_numbers
  emoji: emojis/1F431
  disp_title: sum the numbers
  version: 6
  author: cmdchallenge
  example: paste -sd+ sum-me.txt | bc
  expected_failures:
    - echo 42
  description: |
    The file sum-me.txt has a list of numbers, one per line. Print the sum of these numbers.
  expected_output:
    lines:
      - "42"
- slug: just_the_files
  emoji: emojis/1F981
  disp_title: only the filenames
  version: 5
  author: cmdchallenge
  description: |
    Print all files in the current directory recursively without the leading directory path.
  example: find -type f -printf '%f\n'
  expected_output:
    order: false
    lines:
      - animi.doc
      - corporis.xls
      - odit.doc
      - beatae.flac
      - error.doc
      - libero.xls
      - necessitatibus.doc
      - totam
- slug: remove_extensions_from_files
  emoji: emojis/1F42F
  disp_title: remove extensions
  version: 5
  author: cmdchallenge
  description: |
    Rename all files removing the extension from them in the current directory recursively.
  example: for f in $(find . -type f -name "*.*"); do mv "$f" "${f%.*}"; done
  expected_failures:
    - echo
- slug: replace_spaces_in_filenames
  emoji: emojis/1F434
  disp_title: replace spaces
  version: 5
  author: cmdchallenge
  description: |
    The files in this challenge contain spaces.
    List all of the files (filenames only) in the current directory but replace all spaces with
    a '.' character.
  example: ls | tr ' ' '.'
  expected_output:
    order: false
    lines: ['Adam.Simpson', 'Alexis.Stein', 'Allison.Brown', 'Amy.Anderson', 'Angel.Saunders',
            'Brad.Michael', 'Briana.Wilson', 'Carrie.Alexander', 'Christine.Valdez', 'Christopher.Miller',
            'Claudia.Mccormick', 'Corey.Bird', 'Courtney.Miller', 'Crystal.Dunn', 'Crystal.Valdez',
            'Erica.Richardson', 'James.Harper', 'James.Roberts', 'Jared.Hill.DVM', 'John.Nguyen',
            'Jorge.Ross', 'Joseph.Hurst', 'Karen.Ramirez', 'Kevin.Price', 'Kimberly.Parker', 'Lori.Macias',
            'Luke.Mason', 'Lynn.Robinson', 'Mallory.Peterson', 'Marie.Gutierrez', 'Matthew.Romero',
            'Michaela.Hobbs', 'Molly.Stevens', 'Mr..James.Lopez', 'Mr..Shawn.Martin', 'Mrs..Jade.Clark',
            'Olivia.Irwin', 'Parker.Gilbert', 'Robert.Gregory', 'Robert.Hill', 'Sarah.Hill',
            'Scott.Rice', 'Sheri.Bishop', 'Tamara.Anderson', 'Tammy.Galloway', 'Terri.Young', 'Thomas.Parks',
            'Thomas.Washington', 'Tiffany.Clark', 'Yvonne.Myers']
- slug: dirs_containing_files_with_extension
  emoji: emojis/1F984
  disp_title: directories containing files
  version: 2
  author: cmdchallenge
  description: |
    In this challenge there are some directories containing files with different extensions.
    Print all directories, one per line without duplicates that contain one or more files with a ".tf" extension.
  completions: ['terraform', 'main.tf', 'modules', 'load_balancer', 'main.tf', 'virtual_machine', 'outputs.tf', 'main.tf', 'vpn', 'main.tf', 'files', 'bootstrap.sh', 'templates', 'config.template', 'bin', 'dostuff.sh']
  example: find . -name "*.tf" -type f -exec dirname {} \; | sort | uniq
  expected_output:
    order: false
    re_sub: ['^\./', '']
    lines:
      - 'terraform'
      - 'terraform/modules/load_balancer'
      - 'terraform/modules/virtual_machine'
      - 'terraform/modules/vpn'
- slug: files_starting_with_a_number
  emoji: emojis/1F42E
  disp_title: files starting with a number
  version: 5
  author: cmdchallenge
  description: |
    There are a mix of files in this directory that start with letters and numbers.
    Print the filenames (just the filenames) of all files that start with a number recursively in the current directory.
  completions: ['757Robert Marquez', 'Mr. James Lopez', '974Michael Bowman', '477Thomas Pierce MD', '04Carrie Alexander', '42Robert Hill', '737Jeffrey Davis', '778Holly Archer', '402Nancy Henson', '436Teresa Owens', '48Thomas Allen', '001dir', 'exercitationem.mp3', '3maxime.mp3', 'Jorge Ross', '540Katherine Jones', '682Terri Jones', '639Charles Ferguson', '25Brandon Mcdonald', '132Rebecca Rubio', '78Michelle Spencer', 'Matthew Romero', '670James Jacobs', 'dir', 'provident.avi', '99blanditiis.avi', 'sit.avi', 'nisi.avi', 'totam.avi', '293Linda Bennett', '335John Joseph', '593Brett Martin', '388Andrew Carter', 'tmp', '511Tammy Welch', 'Sheri Bishop']
  example: find . -type f -name '[[:digit:]]*' -printf '%f\n'
  expected_output:
    order: false
    lines: ['974Michael Bowman', '540Katherine Jones', '436Teresa Owens', '04Carrie Alexander', '778Holly Archer',
            '3maxime.mp3', '682Terri Jones', '511Tammy Welch', '293Linda Bennett', '670James Jacobs', '737Jeffrey Davis',
            '42Robert Hill', '25Brandon Mcdonald', '402Nancy Henson', '78Michelle Spencer', '132Rebecca Rubio',
            '639Charles Ferguson', '335John Joseph', '99blanditiis.avi', '477Thomas Pierce MD', '757Robert Marquez',
            '388Andrew Carter', '48Thomas Allen', '593Brett Martin']
- slug: print_nth_line
  emoji: emojis/1F437
  disp_title: nth line
  version: 5
  author: cmdchallenge
  description: |
    Print the 25th line of the file faces.txt
  example: sed -n '25p' faces.txt
  expected_output:
    lines: ['¯\_(ツ)_/¯']
- slug: reverse_readme
  emoji: emojis/1F42D
  disp_title: reverse
  version: 5
  author: cmdchallenge
  description: |
    Print the lines of the file `reverse-me.txt` in this directory in reverse line order so that the last line is printed first and the first line is printed last.

    ```
    ~~~~~~~~~~~~~~~~~~~~~
    In the future
    Environmental destruction will be the norm
    No longer can it be said that
    My peers and I care about this earth
    It will be evident that
    My generation is apathetic and lethargic
    It is foolish to presume that
    There is hope
    ~~~~~~~~~~~~~~~~~~~~~
    -Jonathan Reed "The Lost Generation"
    ```
  example: tac reverse-me.txt
  expected_output:
    lines:
      - '-Jonathan Reed "The Lost Generation"'
      - '~~~~~~~~~~~~~~~~~~~~~'
      - 'There is hope'
      - 'It is foolish to presume that'
      - 'My generation is apathetic and lethargic'
      - 'It will be evident that'
      - 'My peers and I care about this earth'
      - 'No longer can it be said that'
      - 'Environmental destruction will be the norm'
      - 'In the future'
      - '~~~~~~~~~~~~~~~~~~~~~'
- slug: remove_duplicate_lines
  emoji: emojis/1F439
  disp_title: remove duplicates
  version: 5
  author: cmdchallenge
  description: |
    Print the file faces.txt, but only print the first instance of each duplicate line, even if the duplicates don't appear next to each other.

    Note that order matters so don't sort the lines before removing duplicates.
  example: awk '!x[$0]++' faces.txt
  expected_output:
    lines: ['(◕‿◕)', '(^̮^)', 'ʘ‿ʘ', 'ಠ_ಠ', 'ಠ⌣ಠ', 'ಠ‿ಠ', '(ʘ‿ʘ)', '(ಠ_ಠ)', '¯\_(ツ)_/¯',
            '(ಠ⌣ಠ', 'ಠಠ⌣ಠ)', '(ಠ‿ಠ)', '٩◔̯◔۶', 'ヽ༼ຈل͜ຈ༽ﾉ', '♥‿♥', '◔̯◔', '⊙﹏⊙',
            '(¬_¬)', '(；一_一)', '(͡° ͜ʖ ͡°)', '(° ͜ʖ °)', '¯\(°_o)/¯', '( ﾟヮﾟ)', '(︺︹︺)']
- slug: find_primes
  emoji: emojis/1F43B
  disp_title: finding prime numbers
  version: 2
  author: cmdchallenge
  example: 'for num in $(cat random-numbers.txt); do [[ $num == $(factor $num | cut -d" " -f2) ]] && echo $num; done | sort | uniq | wc -l'
  expected_failures:
    - echo 12
  completions: ["random-numbers.txt"]
  description: |
    The file `random-numbers.txt` contains a list of 100 random integers.
    Print the number of unique prime numbers contained in the file.
  expected_output:
    lines:
      - "12"
- slug: print_common_lines
  emoji: emojis/1F43C
  version: 5
  author: amboar
  disp_title: print common lines
  example: "comm -12 <(cut -d' ' -f1 access.log.1 | sort) <(cut -d' ' -f1 access.log.2 | sort)"
  completions: ["access.log.1", "access.log.2"]
  description: |
    `access.log.1` and `access.log.2` are http server logs.

    Print the IP addresses common to both files, one per line.
  expected_output:
    order: false
    lines:
      - 108.68.174.15
      - 17.137.186.194
      - 2.71.250.27
      - 28.151.137.59
- slug: print_line_before
  emoji: emojis/1F423
  disp_title: print line before match
  version: 5
  author: mmr
  example: "awk '/404/{print a}{a=$0}' **/access.log*"
  description: |
    Print all matching lines (without the filename or the file path) in all files under the current directory that start with "access.log", where the next line contains the string "404".

    Note that you will need to search recursively.
  completions: ["access.log"]
  expected_output:
    order: false
    lines:
      - 251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 2477
      - 17.137.186.194 - - [09/Jan/2017:22:43:17 +0100] "GET /pages/create HTTP/1.0" 200 1116
      - 89.148.148.238 - - [09/Jan/2017:22:33:09 +0100] "GET /posts/1/display HTTP/1.0" 502 2477
      - 138.212.253.84 - - [09/Jan/2017:22:53:54 +0100] "GET /posts/foo?appID=xxxx HTTP/1.0" 200 3471
- slug: print_files_if_different
  emoji: emojis/1F99A
  version: 5
  author: anonymous
  disp_title: files that are different
  example: "for i in $(ls *.bin); do if [[ `cmp base.bin $i` ]]; then echo $i; fi; done"
  description: |
    Print all files with a `.bin` extension in the current directory that are different than the file named base.bin.
  expected_output:
    order: false
    lines:
      - test2.bin
      - test4.bin
      - test5.bin
      - test7.bin
- slug: nested_dirs
  emoji: emojis/1F438
  disp_title: tricky file
  version: 6
  author: gitunique
  description: |

    There is a file: `./.../  /. .the flag.txt`

    Show its contents on the screen.
  example: cat ./.../\ \ /.\ .the\ flag.txt
  expected_failures:
    - echo you got it!
  expected_output:
    lines:
      - 'you got it!'
- slug: find_tabs_in_a_file
  emoji: emojis/1F432
  version: 6
  disp_title: find tabs in file
  author: anonymous
  description: |
    How many lines contain tab characters in the file named `file-with-tabs.txt` in the current directory.
  example: grep -P '\t' file-with-tabs.txt | wc -l
  expected_failures:
    - echo 3
  expected_output:
    lines:
      - "3"
- slug: remove_files_without_extension
  emoji: emojis/1F338
  version: 5
  author: bryfry
  disp_title: Remove files without extension.
  description: |
    There are files in this challenge with different file extensions.

    Remove all files without the .txt and .exe extensions recursively in the current working directory.
  example: find . -type f -regextype posix-extended ! -regex ".*(\.txt|\.exe)$" -exec rm {} +
  expected_failures:
    - echo
- slug: remove_files_with_a_dash
  emoji: emojis/1F339
  version: 5
  author: anonymous
  disp_title: Remove files that start with a dash
  description: |
    There are some files in this directory that start with a dash in the filename.  Remove those files.
  example: rm ./-*
  expected_failures:
    - echo
- slug: print_sorted_by_key
  emoji: emojis/1F33A
  version: 5
  author: verovan
  disp_title: Print the content sorted by PID
  description: |
    There are two files in this directory, ps-ef1 and ps-ef2.  Print the contents of both files sorted by PID and delete repeated lines.
  example: cat ps-ef1 > aux; sed '1 d' ps-ef2 >> aux; cat aux | sort -nk2,2 | uniq
  expected_output:
    lines:
      - 'UID        PID  PPID  C STIME TTY          TIME CMD'
      - 'root         1     0  0 mar04 ?        00:00:13 /sbin/init'
      - 'root         2     0  0 mar04 ?        00:00:00 [kthreadd]'
      - 'root         3     2  0 mar04 ?        00:01:07 [ksoftirqd/0]'
      - 'user         5     2  0 mar04 ?        00:00:00 [kworker/0:0H]'
      - 'user         7     2  0 mar04 ?        00:07:06 [rcu_sched]'
      - 'user         8     2  0 mar04 ?        00:00:00 [rcu_bh]'
      - 'root         9     2  0 mar04 ?        00:00:00 [migration/0]'
      - 'root        10     2  0 mar04 ?        00:00:04 [watchdog/0]'
      - 'user        11     2  0 mar04 ?        00:00:04 [watchdog/1]'
      - 'root        12     2  0 mar04 ?        00:00:00 [migration/1]'
      - 'root        13     2  0 mar04 ?        00:00:59 [ksoftirqd/1]'
      - 'user        15     2  0 mar04 ?        00:00:00 [kworker/1:0H]'
      - 'user        16     2  0 mar04 ?        00:00:04 [watchdog/2]'
      - 'root        17     2  0 mar04 ?        00:00:00 [migration/2]'
      - 'root        18     2  0 mar04 ?        00:00:59 [ksoftirqd/2]'
      - 'root        20     2  0 mar04 ?        00:00:00 [kworker/2:0H]'
      - 'user        21     2  0 mar04 ?        00:00:04 [watchdog/3]'
      - 'root        22     2  0 mar04 ?        00:00:00 [migration/3]'
      - 'root        23     2  0 mar04 ?        00:01:29 [ksoftirqd/3]'
- slug: IPv4_listening_ports
  emoji: emojis/1F33B
  version: 5
  author: TaTo69
  disp_title: print the ports
  description: |
    In the current directory there is a file called netstat.out.

    Print all the IPv4 listening ports sorted from the higher to lower.
  example: egrep  "tcp\ .*:**LISTEN" netstat.out | awk '{print $4}' | sed -e 's/.*\://g' | sort -nr
  expected_output:
    lines:
      - '45922'
      - '9090'
      - '8080'
      - '1723'
      - '1254'
      - '1244'
      - '1234'
      - '111'
      - '80'
      - '22'
